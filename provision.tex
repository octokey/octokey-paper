\section{Key distribution}

To provision a new device for a user (i.e. to pair it with their existing devices), we need to
generate a new key split $(d_{i+1,a}, d_{i+1,b})$ such that
$d_{i+1,a} + d_{i+1,b} = d_{i,a} + d_{i,b} \mod \phi(n)$, without reassembling the entire private
exponent $d$ on any single device (and thus risking it being stolen), and without knowing $\phi(n)$.

Say the user has two existing devices $a$ and $b$, storing $d_{i,a}$ and $d_{i,b}$ respectively. We
now want to introduce a new device $c$ and pair it with $a$. To this end, $c$ generates a uniformly
distributed random number $d_{i+1,c}$ with $0 < d_{i+1,c} < 2^n$, and another uniformly distributed
random number $g$ with $0 < g < d_{i+1,c}$.

By exchanging a sequence of messages, the devices can arrive in the desired state. The algorithm
will be described in the full paper.

\subsection{Key rotation}
\subsection{Multiple keypairs per user}
\subsection{Security levels}
\subsection{Device-to-device communication}

