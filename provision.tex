\section{Inter-device communication}\label{sec:interdevice}

Octokey assumes that the user has multiple internet-connected devices: two at minimum (one physical
device and one remote key fragment store), but likely several more (desktop computer, laptop,
smartphone, tablet, game console, television, automobile, etc).

We assume that users want to be able to access all of their services on any one of their physical
devices (devices with partial access to the user's services are discussed in
section~\ref{sec:delegation}). Thus, each physical device should be paired at minimum with the
remote key fragment store. Some physical devices may also be paired with each other, to provide
redundancy in case of a failure of the remote store (discussed in section~\ref{sec:threat}).

The system should make it easy to add new devices to the user's set of trusted devices, and to
revoke any devices which are lost or no longer in use. It may also provide convenience features,
such as synchronizing the list of usernames for all of a user's services, so that they can be
autofilled in login forms. In order to do this, Octokey needs a mechanism for the user's devices to
synchronize with each other.

\subsection{Communication protocol}

First, we need to be able to establish a secure point-to-point communication channel between any two
of the user's devices (treating the remote store as one of the devices). The channel must provide
secrecy and integrity, so that an attacker cannot eavesdrop or modify communcation between devices.
It must also prevent spoofing, so that an attacker cannot impersonate a device.

TLS~\cite{TLS} meets these requirements. Each device generates its own private key and self-signed
certificate, which are used only for inter-device communication and are independent from the mRSA
key fragments. One device then connects to another and performs a TLS handshake, using the devices'
certificates as client and server certificates for mutual authentication.

This approach does not require any PKI or certificate authorities: public key fingerprints are
exchanged out-of-band when devices are first discovered (see section~\ref{sec:newdevice}), so each
device can check whether its peer is the device that it claims to be. It is not important which
device acts as client or server in this channel, as the relationship between the devices is
symmetric.

However, there is a practical problem: it can be difficult to establish a peer-to-peer TCP
connection between two arbitrary devices, as they may be on different networks, behind firewalls,
and they may often be offline -- and rarely online at the same time. Thus, rather than performing
TLS over TCP, we propose using an alternative transport layer in the form of a store-and-forward
service.

The store-and-forward service is a web service that can be reached from all devices (it may be
co-located with the remote key fragment store). It accepts messages from one device and relays them
to another device: if the recipient is online, the messages are forwarded immediately, otherwise
they are stored until the recipient is next online. The messages are records of the TLS Record
Protocol~\cite{TLS}, so two devices can perform a TLS handshake and establish a secure channel by
sending each other messages via the store-and-forward service. The service needs to be highly
available, but it does not need to be trusted for security purposes.

If devices are only occasionally online, the round-trip-times across this ``network connection'' may
be measured in days, so timeouts may need to be adjusted accordingly. However, once this channel has
been set up, it can remain open indefinitely (with occasional renegotiation), even across device
reboots.

\subsection{Data synchronization}\label{sec:devicesync}

We can now use these secure point-to-point channels between devices to create a mesh of connections
amongst the user's devices. It is not necessary to have a communication channel between every pair
of devices, but a fairly densely connected graph of channels is desirable, so that any message from
one devices reaches the other devices fairly quickly.

\subsection{Adding a new device}\label{sec:newdevice}

\subsection{Key distribution}

To provision a new device for a user (i.e. to pair it with their existing devices), we need to
generate a new key split $(d_{i+1,a}, d_{i+1,b})$ such that
$d_{i+1,a} + d_{i+1,b} = d_{i,a} + d_{i,b} \mod \phi(n)$, without reassembling the entire private
exponent $d$ on any single device (and thus risking it being stolen), and without knowing $\phi(n)$.

Say the user has two existing devices $a$ and $b$, storing $d_{i,a}$ and $d_{i,b}$ respectively. We
now want to introduce a new device $c$ and pair it with $a$. To this end, $c$ generates a uniformly
distributed random number $d_{i+1,c}$ with $0 < d_{i+1,c} < 2^n$, and another uniformly distributed
random number $g$ with $0 < g < d_{i+1,c}$.

By exchanging a sequence of messages, the devices can arrive in the desired state. The algorithm
will be described in the full paper.

\subsection{Key rotation}
\subsection{Multiple keypairs per user}
\subsection{Security levels}
\subsection{Device-to-device communication}

% Sync login history across devices, and compare to login history reported by server, to detect
% use of a stolen key

\subsection{Delegated login by mobile device}\label{sec:delegation}

A user should be able to authenticate with services on a semi-trusted device, for example a game
console at a friend's home, without having to provision key fragments for that device (and thus
giving the device full access to all of the user's accounts). To this end, we use the fact that a
signed Octokey authentication request is like a one-time password: it can be given to another device
in order to authorize one-off access to one particular service.

By logging in, the semi-trusted device exchanges the signed authentication request for a session
identifier (e.g. a cookie), which is destroyed when the user logs out, or after a timeout. In cases
where the user wants to give a device long-lived access to one service, the device can obtain an
OAuth~\cite{OAuth} token from the service. This is standard use of OAuth and does not require any
special support from Octokey.

The question is then how to get the signed authentication request onto the device that needs it. We
propose the following flow:

\begin{enumerate}
\item 
\end{enumerate}

In cases where an internet connection is not available on both devices, Bluetooth or NFC can be
used.

Browser and phone meet at rendezvous point (URL in QR code) / communicate over rendezvous channel

We must assume that the contents of the barcode can be read by an attacker: it may be
electromagnetically snooped~\cite{Kuhn05}, or an attacker may simply point a camera at the victim's
screen. In order to establish a secure channel between the smartphone and the desktop browser, it is
therefore not appropriate to embed a symmetric private key in the barcode.

The browser has a separate keypair, with the private key identifying the browser itself (not the
user). The QR code contains the URL of the rendezvous point, and the fingerprint of the browser's
public key. When the rendezvous channel is established, the browser sends a message to the client
signed with the browser's private key; and the client checks the signature, and checks that the
fingerprint of the public key that made the signature matches the fingerprint in the QR code. Thus
man-in-the-middling would require an attacker to actually modify the on-screen QR code, rather than
just eavesdrop it. If the attacker has enough access to the device that they are able to manipulate
what is displayed on the screen, then they can impersonate the user after logging in anyway (so all
bets are off for that user account on that site). The user still needs to make sure that they are
not being tricked into logging in to a different site from the one they thought they were logging in
to; this can be done by displaying the URL of the login page on the mobile phone when the user is
prompted to approve the authentication request. If the URL is not what the user was expecting, they
must decline the authentication request.
