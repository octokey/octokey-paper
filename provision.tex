\section{Key distribution}

To provision a new device for a user (i.e. to pair it with their existing devices), we need to
generate a new key split $(d_{i+1,a}, d_{i+1,b})$ such that
$d_{i+1,a} + d_{i+1,b} = d_{i,a} + d_{i,b} \mod \phi(n)$, without reassembling the entire private
exponent $d$ on any single device (and thus risking it being stolen), and without knowing $\phi(n)$.

Say the user has two existing devices $a$ and $b$, storing $d_{i,a}$ and $d_{i,b}$ respectively. We
now want to introduce a new device $c$ and pair it with $a$. To this end, $c$ generates a uniformly
distributed random number $d_{i+1,c}$ with $0 < d_{i+1,c} < 2^n$, and another uniformly distributed
random number $g$ with $0 < g < d_{i+1,c}$.

By exchanging a sequence of messages, the devices can arrive in the desired state. The algorithm
will be described in the full paper.

\subsection{Key rotation}
\subsection{Multiple keypairs per user}
\subsection{Security levels}
\subsection{Device-to-device communication}
\subsection{Threats}
Undetected malware on a compromised machine can secretly log in to the user's services. If it's not
noticed, it can't be revoked. But that is true of any software-based solution; only dedicated
cryptographic hardware can prevent this, and we don't want to rely on hardware, as discussed in the
introduction.

\subsection{Channel binding}

Question: how to bind the Octokey signature to the TLS channel in a mobile app, where the TLS
connection will probably get torn town when switching to the Octokey app? Set up OBC first (before
login)?

Origin-Bound Certificates (OBC)~\cite{Dietz12} should be used to protect the session cookie from
MITM attackers.

Note that channel binding does not protect against all MITM attack scenarios. For example, in an
e-commerce setting, an attacker who has stolen the service's private key, or who has fraudulently
obtained a certificate from a CA trusted by the user's browser, can still impersonate the service.
If the user does not notice the impersonation, and enters their credit card number to make a
purchase, the attacker is able to steal the credit card number. In situations like these -- where
the user is providing confidential information to the service -- the PKI still needs to be trusted.

However, in situations where the flow of confidential information is from the service to the
authenticated user, channel binding is an effective additional protection against MITM attacker
trying to steal that information.

Another attack vector is via JavaScript injected into the user's browser by a MITM attacker. Any
code that executes within the context of a document in the browser has full access to the contents
of that document. A page that is served to an authenticated user may download JavaScript code on
separate TLS connections, for example from a content delivery network (CDN). If a MITM attacker is
able to impersonate the CDN, they can inject arbitrary JavaScript into the browser.

To prevent this, the page should not directly execute JavaScript that is downloaded. Instead, it
should fetch JavaScript from the server using XMLHttpRequest over an authenticated TLS connection. 
