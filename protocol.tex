\section{Octokey protocol overview}

Octokey is a user authentication protocol designed to meet the goals stated in the introduction. It
aims to provide good security in a software-only configuration, with cryptographic hardware modules
being an optional enhancement. It strives to be a \emph{trust-free} protocol: it is completely
decentralized, there is no dependency on any identity provider, and the extent to which PKI
certificate authorities need to be trusted is minimized as far as possible.

The basic operation of Octokey is inspired by SSH public key authentication, which is widely used
for shell access to remote servers. When using Octokey for the first time, a user must generate a
RSA keypair.\footnote{We hope that the approach could be extended to support other public-key
cryptosystems such as ECC.} When the user signs up to a service, or migrates from another
authentication method to Octokey, the user submits their public key to the service. This is
analogous to creating a password when a user first signs up to a service.

Whenever the user wishes to log in, they must prove ownership of the private key. A client does this
by requesting a challenge from the server, signing it using the private key, and submitting the
signature to the server. The details of this protocol are given below.

We can think of Octokey as a machine-to-machine authentication protocol, and it needs to be preceded
by a human-to-machine authentication step: for example, a password or biometric information can be
used by the client device to unlock or decrypt the private key. However, since this password or
biometric information is not sent over the network, this concern is orthogonal to the
machine-to-machine authentication. Any improvements in biometric sensors, for example, do not
require any changes to the Octokey protocol or any support by service providers.

If a password is used to decrypt the user's private key, they need only remember a single password
per device (or perhaps per keypair), but not a separate password for every service where they have
an account. We believe that a single password is an acceptable user experience.

\subsection{Authentication requests}

Each user has a RSA keypair $(n, d, e)$ where $n$ is the modulus, $d$ is the private exponent and
$e$ is the public exponent. When signing up to a service, the user submits their public key
$(n, e)$ to the service. The service stores the public key as part of the user record.

To log in, the client first requests a challenge $c$ from the service via a HTTP endpoint. It then
calculates $m = H(c, u, r)$ where $u$ is the URL of the service endpoint and $r$ is the user's
registered username. $H$ encodes its arguments as a binary string and then applies the
\textsc{EMSA-PSS-Encode} operation (hashing and padding) as defined in PKCS\#1.~\cite{PKCS1} From
that, the RSA signature can be calculated as $s = m^d \mod n$.

The client then constructs the authentication request, which is an encoding of the tuple
$(s, c, u, r, n, e)$. The authentication request is sent to the server as part of a HTTP request
over TLS, and is handled at the application layer. The server can verify the authentication request
by checking that all of the following are true:
\begin{itemize}
\item $s$ is a valid PKCS\#1 signature of the values $(c, u, r)$, checked against the public key
$(n, e)$.
\item $c$ is a valid challenge issued by this service, has not been used for login before, and is
not older than some maximum age. This prevents replay attacks.
\item $u$ is a valid URL for this service. A login request for an unknown URL must be rejected.
This prevents phishing-like attacks, whereby an attacker creates an imitation website under a
similar-looking URL and tricks the user into logging in.
\item $r$ is a registered username for this service, and $(n, e)$ is a public key for that user.
\end{itemize}
If the authentication request is successfully verified, the user is logged in by the server in the
usual manner, for example by setting an appropriate session cookie.

\subsection{Protection against key theft}\label{sec:revocation}

Many users have multiple devices (e.g. laptop, smartphone, tablet, game console) on which they need
to be able to log in to their accounts with online services. As described above, the private key
$(n, d, e)$ would need to be copied to each of those devices. If any of those devices is lost or
compromised, and an attacker can break the human-to-machine authentication step (perhaps due to a
weak password on the private key), the attacker could gain access to all of a user's accounts.

To mitigate this risk, we ensure that the private exponent $d$ is never stored on any one device.
Instead, we split it into key fragments that are distributed among the user's devices. We use the
\emph{mediated RSA} (mRSA) scheme~\cite{Boneh01} which is based on the fact that
$$s = m^d = m^{d_a + d_b} = m^{d_a} m^{d_b} \mod n$$ provided that $d = d_a + d_b \mod \phi(n)$.

If two devices $a$ and $b$ each have a key fragment $d_a$ and $d_b$ respectively, and those
fragments sum to the private exponent $d$, then we call those devices \emph{paired}. In order to
generate a valid signature, any two paired devices need to collaborate. If device $a$ wants to
generate an authentication request, it can send $(c, u, r)$ to device $b$, which may first ask the
user to confirm whether they wish to log in to URL $u$ using username $r$. If yes, $b$ calculates
$H(c, u, r)^{d_b} = m^{d_b}$ and returns that value to $a$. Then $a$ can calculate
$s = m^{d_a} m^{d_b}$ by using its own key fragment $d_a$ and the value returned by $b$, and thus
log in.

If a device is lost, stolen or compromised, this scheme allows the user to revoke that device's
login capability: every device that is paired with the lost device must be instructed to delete the
key fragment corresponding to the lost device. When all the paired fragments have been deleted, the
key fragments on the lost device become useless. Thus, even if the human-to-machine authentication
is weak, not all is lost: the user only needs to revoke the lost device's key fragments faster than
an attacker can break the human-to-machine authentication.

A key could also be split into more than two fragments, which would protect against the case where
an attacker manages to steal two or more devices. However, this comes at the cost of a more
cumbersome user experience, so we concentrate on the two-fragment case for now.

\subsection{Remote key fragment store}\label{sec:fragmentstore}

Authenticating by using paired physical devices (e.g.\ a laptop and a smartphone) yields a similar
user experience to current 2-factor authentication solutions, whereby the user must fetch the phone
from their pocket, launch the appropriate app, and perform some kind of handshake. This is
possible, but distinctly less convenient for users than typing a password, so it is not the simple
user experience we are looking for.

However, there is a simple solution within the mRSA framework: one of the user's `devices' may be a
remote service on the internet. This service stores key fragments that are paired with each of the
user's physical devices, and responds to signing requests by performing the modular exponentiation
using its key fragments. This allows a user to authenticate with services using only one physical
device -- the coordination with the remote key fragment store happens automatically behind the
scenes.

The key fragment store need only be partially trusted. It cannot authenticate as the user without
the cooperation of one of the user's physical devices. The user only needs to trust the key fragment
store to not collude with attackers who steal devices, and to delete key fragments when the user
requires key revocation.

From the point of view of an online service, the key fragment store does not even exist: a service
simply verifies the RSA signature on an authentication request, and does not care how that signature
was constructed. This is in contrast to federated login systems, where the relying party must trust
the identity provider.

\subsection{Rate limiting password guesses}\label{sec:ratelimit}

Besides enabling key revocation, mRSA can also be used to strengthen the human-to-machine
authentication step against offline attacks.

For example, say the key fragment on a device is encrypted with a symmetric key derived from a
password.\footnote{This discussion also applies to other human-to-machine authentication methods,
for example an encryption key that is derived from biometric measurements.} Consider an attacker who
has stolen this encrypted fragment. In order to brute-force the password, the attacker needs a way
of determining whether a password guess is correct. However, a key fragment is just a uniformly
distributed random number; by itself, the correctly decrypted key fragment is indistinguishable from
the garbage that results from trying to decrypt with the wrong password.\footnote{If the encryption
uses a block cipher, the key fragment must be padded with random bits up to the block size. Padding
with zeros would leak information on whether a password guess was correct.}

Assuming the attacker has no other key fragments, they can only determine whether the password guess
was correct by communicating with the remote key fragment store and testing whether they are able to
construct a valid PKCS\#1 signature. This gives us an opportunity to rate-limit password guessing
attempts: if the remote store receives too many requests based on an incorrect password, it can
block further attempts and advise the user to revoke the device pairing.

In order to achieve this, we must design the protocol such that an attacker must communicate with
the remote store for every password attempt, but without revealing the password or the decrypted key
fragment to the remote store. We can do this as follows:

Say the key fragment $d_a$ has been encrypted with password $\mathit{pass}$, and the attacker has
stolen the encrypted fragment
$$\mathit{efrag} = \mathrm{encrypt}(\mathrm{PBKDF2}(\mathit{pass}), d_a).$$
The attacker now guesses $\mathit{pass}^\prime$ and computes a guess $d_a^\prime$ of the plaintext:
$$d_a^\prime = \mathrm{decrypt}(\mathrm{PBKDF2}(\mathit{pass}^\prime), \mathit{efrag})$$
To check whether $d_a^\prime = d_a$ the attacker needs to contact the remote store where $d_b$ is
held. We previously said that a signing request to the store consists of $(c, u, r)$. We now extend
this to require an additional parameter:
$$\left(c, u, r, H(H(c, u, r))^{d_a^\prime}\right)$$
The additional parameter allows the store to verify whether the client's $d_a^\prime$ is correctly
decrypted, without revealing $d_a^\prime$ or the password. The store simply uses its own $d_b$ to
compute $$H(H(c, u, r))^{d_a^\prime}H(H(c, u, r))^{d_b}$$ and checks whether the result is a valid
PKCS\#1 signature for the user's public key $(n, e)$.

If the signature is valid, the store computes $H(c, u, r)^{d_b}$ as before, and returns it to the
client. If the signature is not valid, the store returns ``bad signature''. The attacker learns that
the password guess $\mathit{pass}^\prime$ was incorrect, but otherwise nothing is revealed that
would help them guess the password.

The values $(c, u, r)$ are hashed twice so that the store cannot use the signature to make any
authentication requests on behalf of the user.

This protection only works if the attacker does not have any knowledge of previous requests to the
store. If the attacker knows $x^{d_a}$ (a request) or $x^{d_b}$ (a response) for any $x$, they can
brute-force the password without contacting the remote store, and thus circumvent the rate-limiting.
It is therefore important that communication with the remote store is protected from eavesdropping
(using TLS) and is not logged on the device.

\subsection{Channel binding and preventing MITM}\label{sec:channelbinding}

Once a device has assembled a signature for an authentication request, that signature has the
function of a one-time password: if an attacker can intercept it before it reaches the intended
service, the attacker can use it to impersonate the user. It is therefore essential that the
authentication request is sent over TLS.

However, TLS connections are susceptible to man-in-the-middle attacks using forged TLS certificates,
due to users ignoring warnings about invalid certificates, or due to malware. Such incidents have
been observed in practice.~\cite{Huang14, Adkins11}

Some authentication methods such as SCRAM-SHA-1-PLUS~\cite{SCRAM} use \emph{channel binding} to
prevent MITM attacks. For example, the \texttt{tls-unique} channel binding type works by hashing the
handshake messages that established the TLS connection: in a direct connection, server and client
obtain the same hash value, but if the connection was terminated and restarted by a MITM, the server
and client's values differ. If the client incorporates this hash value into the authentication
request (such that it cannot be changed by the MITM), and the server checks that it equals the
server-side view of the connection, then an authentication request is rendered invalid by the
presence of a MITM.

Origin-Bound Certificates~\cite{Dietz12} generalize this idea to the web, creating a channel
binding that is not tied to a particular TCP connection. When a client first connects to a
particular domain name, it automatically creates a TLS client certificate (without any user
interaction) and presents it to the server. This certificate does not have any authentication
purpose, but the fingerprint of the certificate can be incorporated as channel identifier into an
authentication request.

While channel binding would yield a significant improvement in security, it would also make the
protocol much harder to deploy, both on the client and on the server side. It would therefore likely
have to be an optional extension.

An alternative effort to prevent MITM is the Certificate Transparency project~\cite{CertTrans},
which aims to strengthen trust in the PKI by providing a public audit log of issued certificates,
and rejecting certificates that do not appear in the log. Certificate Transparency does not protect
against attackers who have stolen a website's private key (or governments, which can obtain the
private key with a court order), but it does prevent more casual kinds of MITM attacks, so it may be
sufficient.
