\documentclass{article}
\usepackage{cite}
\usepackage{hyperref}
\usepackage{amsmath}

\begin{document}
\title{Octokey: Public key authentication for the web}
\author{Martin Kleppmann \and Conrad Irwin}
\date{\today}
\maketitle

\begin{abstract}
We propose Octokey, a cryptographic protocol for authenticating users, designed as a viable
replacement for password authentication in consumer internet use cases. When a user signs up to a
service, they provide a public key. Clients subsequently authenticate by presenting a challenge
signed with the user's private key, similar to SSH public key authentication. We also describe
protocols which allow users to log in to their accounts on multiple devices, provision new devices,
and revoke keys on devices that are lost or stolen.
\end{abstract}

\emph{Note: We, the authors, have a background in developing commercial web applications. In the
field of crypography, we are merely keen amateurs. We are aware that amateur cryptography is prone
to catastrophic flaws, and we fully expect such flaws to be found in the ideas we are proposing.
However, we have experience designing real-world systems with good user experiences, a perspective
that we feel is often lacking in security research. We would appreciate the opportunity to present
our ideas to the cryptography and information security experts at RWC 2015, in order to stimulate a
discussion and seek feedback from all sides. We believe that such collaboration could lead to a
viable replacement for passwords that has eluded us for so long.}

\section{Existing authentication systems}

Despite their many well-known flaws, passwords are still by far the most commonly used
authentication system on the web.~\cite{Bonneau12} As users sign up for ever more services, their
use is becoming increasingly unsustainable. However, the alternatives are also unappealing:

\begin{description}
\item[Password managers] remove the burden of remembering passwords, but passwords are still
susceptible to being stolen by malware, man-in-the-middle attackers or eavesdropping on SSL-stripped
connections.
\item[Federated login] such as OpenID, Facebook Connect or Mozilla Persona requires that the relying
party trusts the identity provider to correctly authenticate the user. If the identity provider has
an outage, goes out of business or is compromised, the relying party is in a difficult situation.
For that reason, very few major websites accept federated login.
\item[One-time passwords] can be sent by email or SMS (essentially a federated login scheme, as the
authentication is delegated to the email provider or mobile network provider), generated by a
hardware token or mobile app (clumsy user experience) or generated and printed out in advance
(inconvenient).
\item[TLS client certificates] have been successfully adopted in some environments, e.g.\ by banks
and utility companies in Estonia.~\cite{Parsovs14} However, they are complicated to use, and don't
adapt well to mobile devices and multi-device usage. Certificate revocation is problematic.
\item[Secure hardware modules] (e.g. FIDO~\cite{FIDOOverview} and Pico~\cite{Stajano11}) burden the
user with another device to carry around, and have hardware compatibility problems (e.g. a USB-based
module cannot be used with a phone that has no USB port). It is unclear how to revoke a key that is
lost or stolen.
\end{description}

For consumer internet purposes, ease of sign-up and ease of login are essential, and mechanisms
which add inconvenience are unlikely to gain wide adoption. In order to be viable, an alternative
authentication system must be \emph{more} convenient than a password, and also more secure.

\section{The Octokey protocol in brief}

The basic operation of Octokey is similar to SSH public key authentication. Each user has a RSA
keypair $(n, d, e)$ where $n$ is the modulus, $d$ is the private exponent and $e$ is the public
exponent. When signing up to a service, the user submits their public key $(n, e)$.

To log in, the client first requests a challenge $c$ from the service. It then calculates
$m = H(c, u, r)$ where $u$ is the URL of the service endpoint and $r$ is their registered username.
$H$ encodes its arguments as a binary string and then applies the \textsc{EMSA-PSS-Encode} operation
(hashing and padding) as defined in PKCS\#1.~\cite{PKCS1}

The client then sends $(m^d \mod n, c, u, r, n, e)$ to the server. The server can verify the
signature by checking all of the following:

\begin{itemize}
\item $m^d \mod n$ is a valid PKCS\#1 signature of the values $(c, u, r)$, checked against the
public key $(n, e)$.
\item $c$ is a valid challenge issued by this service, has not been used for login before, and is
not older than some maximum age.
\item $u$ is a valid URL for this service. A login request for an unknown URL must be rejected.
\item $r$ is a registered username for this service, and $(n, e)$ is a public key for that user.
\end{itemize}

\subsection{Key revocation}

To support key revocation, we use the mRSA scheme proposed by Boneh et al.~\cite{Boneh01} The
private exponent $d$ is never stored on any one device. Instead, it is split into pairs such that
$d = d_{1,a} + d_{1,b} = d_{2,a} + d_{2,b} = \dots \mod \phi(n)$ and the key fragments are
distributed across several devices controlled by the user. If two devices each have one of the
summands of such a pair, we call the devices \emph{paired}.

Now any two paired devices need to collaborate in order to generate a valid signature: since
$m^d = m^{d_{1,a} + d_{1,b}} = m^{d_{1,a}} m^{d_{1,b}} \mod n$, each device can perform its own
exponentiation, and the client that wants to log in can multiply the two results in order to obtain
a valid signature.

If a device is lost or stolen, the user can revoke its access by instructing all devices that are
paired with the lost device to delete their key fragment that corresponds to the lost device.

For convenience, one of the user's devices may be an online service. That service only needs to be
trusted to store key fragments, and to delete them when instructed (it does not have the ability to
log in to any accounts by itself). This service does not need to be trusted by any website using
Octokey authentication.

\subsection{Key distribution}

To provision a new device for a user (i.e. to pair it with their existing devices), we need to
generate a new key split $(d_{i+1,a}, d_{i+1,b})$ such that
$d_{i+1,a} + d_{i+1,b} = d_{i,a} + d_{i,b} \mod \phi(n)$, without reassembling the entire private
exponent $d$ on any single device (and thus risking it being stolen), and without knowing $\phi(n)$.

Say the user has two existing devices $a$ and $b$, storing $d_{i,a}$ and $d_{i,b}$ respectively. We
now want to introduce a new device $c$ and pair it with $a$. To this end, $c$ generates a uniformly
distributed random number $d_{i+1,c}$ with $0 < d_{i+1,c} < 2^n$, and another uniformly distributed
random number $g$ with $0 < g < d_{i+1,c}$.

By exchanging a sequence of messages, the devices can arrive in the desired state. The algorithm
will be described in the full paper.

\subsection{Delegated authentication}

Users should be able to perform a one-time login to specific services on a device without
transferring their key to that device. For example, they may temporarily want to log in to their
account on a friend's gaming console.

To achieve this, the device requesting login displays a 2D barcode on its screen, and the user scans
it with the camera of a mobile device that can perform the authentication (perhaps paired with a
remote server). The barcode contains a TCP endpoint to which the mobile device can connect, and
the devices can exchange the challenge and signature for a particular authentication request through
that channel.

This provides security comparable to a one-time password, but is much more convenient to use.

\subsection{Channel binding}

Channel binding can be used to protect against a signed challenge being stolen by a MITM attacker.
We are considering origin-bound certificates~\cite{Dietz12} (the fingerprint of the OBC can be
incorporated into the authentication signature). This does not change the user experience, but it
increases the difficulty of implementing Octokey, so we propose making it an optional feature.

\section{Implementation}

We are working on a prototype implementation which allows us to explore the user experience aspects
of the system.

Our intention is to make implementations of both the server and the client side available freely as
open source, and to work towards defining the protocol as an open standard that anyone can
implement.

At this stage, we are seeking feedback from the cryptography and information security community to
improve this proposal.

\bibliography{references}{}
\bibliographystyle{plain}
\end{document}
